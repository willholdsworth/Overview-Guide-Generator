<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PRODUCT OVERVIEW GUIDE GENERATOR</title>
    <style>
body {
    font-family: Open Sans, sans-serif;
    margin: 0;
    padding: 20px;
}

.container {
    width: calc(297mm - 40px);
    margin: 0 auto;
}

textarea {
    width: 100%;
    height: 100px;
    margin-bottom: 20px;
}

.a4-container {
    width: 100%;
    height: 210mm;
    border: 1px solid #000;
    padding: 20px;
    box-sizing: border-box;
    position: relative;
    page-break-after: always;
    margin-bottom: 20px;
}

.logo {
    width: 100px;
    position: absolute;
    top: 20px;
    left: 20px;
}

.title {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    text-align: center;
    white-space: nowrap;
    font-weight: bold;
    letter-spacing: 0.05rem;
}

.contact-info {
    position: absolute;
    top: 20px;
    right: 20px;
    text-align: right;
    font-size: 8pt;
}

.table-wrapper {
    position: absolute;
    top: 80px;
    left: 20px;
    right: 20px;
    bottom: 70px;
    display: flex;
    overflow: hidden;
    border-top: 1px solid black;
    border-bottom: 1px solid black;
    border-left: 1px solid black;
}

.section-table {
    flex: 1;
    border-collapse: collapse;
    margin: 0;
    table-layout: fixed;
    height: 100%;
}

.section-table:not(:first-child) {
    border-left: 2px solid black;
}

.section-table th, .section-table td {
    border-right: 1px solid black;
    text-align: center;
    padding: 2px;
    overflow: hidden;
}

.section-table th:last-child, .section-table td:last-child {
    border-right: none;
}

.section-table:last-child th:last-child, 
.section-table:last-child td:last-child {
    border-right: 1px solid black;
}

.section-table td:first-child, .section-table th {
    background-color: black;
    color: white;
}

.section-table th a {
    color: white;
}

.section-table td.specifications {
    background-color: black;
    color: white;
    text-transform: uppercase;
}

.section-table td img {
    display: block;
    margin: 0 auto;
    max-width: 100%;
    height: auto;
}

.section-table tr.grey-row {
    background-color: #f2f2f2;
}

.section-table tr.white-row {
    background-color: white;
}

.section-table .group-row th {
    background-color: #707070;
    color: white;
}

.section-table .group-row th:first-child {
    background-color: black;
    color: white;
}

.footer {
    position: absolute;
    bottom: 20px;
    width: 100%;
    text-align: center;
    font-size: 8px;
}

.styled-button {
    padding: 5px 5px;
    margin: 1px;
    background-color: green;
    color: white;
    border: 2px solid white;
    border-radius: 5px;
    cursor: pointer;
    user-select: none;
}

.styled-button:active {
    background-color: grey;
}

.toggle-button {
    padding: 5px 5px;
    margin: 1px;
    background-color: #303030;
    color: white;
    border: 2px solid white;
    border-radius: 5px;
    cursor: pointer;
    user-select: none;
}

.toggle-button.active {
    background-color: lightgrey;
    color: black;
}

.button-container {
    margin-bottom: 20px;
}

.section-controls {
    display: inline-block;
    margin-right: 20px;
    vertical-align: top;
}

.section-title {
    font-weight: bold;
    margin-bottom: 5px;
    color: #333;
}

td a {
    color: inherit;
    text-decoration: underline;
}

.cell-value {
    margin-bottom: 2px;
    line-height: 1.2;
}

.cell-value:last-child {
    margin-bottom: 0;
}

.cell-value strong {
    font-size: 1em;
    font-weight: lighter;
    color: #000;
    display: inline;
}

.checkbox-container {
    display: inline-block;
    margin-left: 10px;
    vertical-align: middle;
}

.progress-container {
    width: 100%;
    height: 20px;
    background-color: #f2f2f2;
    border-radius: 5px;
    margin-top: 10px;
    margin-bottom: 20px;
    display: none;
}

.progress-bar {
    height: 100%;
    background-color: #4CAF50;
    border-radius: 5px;
    width: 0%;
    transition: width 0.3s ease-in-out;
}

.dropdown-toggle {
    padding: 5px 10px;
    background-color: lightgrey;
    color: black;
    border: 2px solid white;
    border-radius: 5px;
    cursor: pointer;
    margin-bottom: 10px;
    display: inline-block;
    position: relative;
    padding-right: 30px;
}

.dropdown-toggle::after {
    content: '▼';
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 0.8em;
}

.dropdown-toggle.active::after {
    content: '▲';
}

.dropdown-content {
    display: none;
    margin-bottom: 10px;
}

.dropdown-content.show {
    display: block;
}

@media print {
    * {
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
    }
    
    body {
        margin: 0 !important;
        padding: 0 !important;
        font-family: Open Sans, sans-serif !important;
    }
    
    .container {
        width: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
    }
    
    .container > h1,
    .container > textarea,
    .container > button,
    .container > .checkbox-container,
    .container > .progress-container,
    .container > .dropdown-toggle,
    .container > .dropdown-content {
        display: none !important;
    }
    
    .dropdown-toggle,
    .dropdown-content,
    .page-wrapper > .dropdown-toggle,
    .page-wrapper > .dropdown-content {
        display: none !important;
    }
    
    .a4-container {
        width: 100% !important;
        height: 100vh !important;
        margin: 0 !important;
        padding: 20px !important;
        border: none !important;
        box-sizing: border-box !important;
        page-break-before: always;
        page-break-after: always;
        page-break-inside: avoid;
        position: relative !important;
        display: block !important;
    }
    
    .a4-container:first-of-type {
        page-break-before: avoid;
    }
    
    .a4-container:last-of-type {
        page-break-after: avoid;
    }
    
    .logo {
        position: absolute !important;
        top: 20px !important;
        left: 20px !important;
        width: 100px !important;
        display: block !important;
    }
    
    .title {
        position: absolute !important;
        top: 20px !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        text-align: center !important;
        font-weight: bold !important;
        letter-spacing: 0.05rem !important;
        display: block !important;
    }
    
    .contact-info {
        position: absolute !important;
        top: 20px !important;
        right: 20px !important;
        text-align: right !important;
        font-size: 8pt !important;
        display: block !important;
    }
    
    .table-wrapper {
        position: absolute !important;
        top: 80px !important;
        left: 20px !important;
        right: 20px !important;
        bottom: 70px !important;
        border-top: 1px solid black !important;
        border-bottom: 1px solid black !important;
        border-left: 1px solid black !important;
        display: flex !important;
        overflow: visible !important;
    }
    
    .section-table {
        flex: 1 !important;
        border-collapse: collapse !important;
        table-layout: fixed !important;
        height: 100% !important;
        display: table !important;
    }
    
    .section-table:not(:first-child) {
        border-left: 2px solid black !important;
    }
    
    .section-table thead {
        display: table-header-group !important;
    }
    
    .section-table tbody {
        display: table-row-group !important;
    }
    
    .section-table tr {
        display: table-row !important;
        page-break-inside: avoid;
    }
    
    .section-table tr[style*="display: none"] {
        display: none !important;
    }
    
    .section-table th, .section-table td {
        display: table-cell !important;
        padding: 2px !important;
        border-right: 1px solid black !important;
        text-align: center !important;
        overflow: hidden !important;
    }
    
    .section-table th:last-child, .section-table td:last-child {
        border-right: none !important;
    }
    
    .section-table:last-child th:last-child, 
    .section-table:last-child td:last-child {
        border-right: 1px solid black !important;
    }
    
    .section-table td:first-child, .section-table th {
        background-color: black !important;
        color: white !important;
    }
    
    .section-table th a {
        color: white !important;
        text-decoration: underline !important;
    }
    
    .section-table .group-row th {
        background-color: #707070 !important;
        color: white !important;
    }
    
    .section-table .group-row th:first-child {
        background-color: black !important;
        color: white !important;
    }
    
    .section-table .grey-row {
        background-color: #f2f2f2 !important;
    }
    
    .section-table .white-row {
        background-color: white !important;
    }
    
    .section-table td img {
        display: block !important;
        margin: 0 auto !important;
        max-width: 100% !important;
        height: auto !important;
        object-fit: contain !important;
    }
    
    .section-table tbody tr:first-child {
        vertical-align: middle !important;
    }
    
    .section-table tbody tr:first-child td {
        vertical-align: middle !important;
    }
    
    .footer {
        position: absolute !important;
        bottom: 20px !important;
        left: 20px !important;
        right: 20px !important;
        text-align: center !important;
        font-size: 8px !important;
        display: block !important;
    }
}
    </style>
</head>
<body>
    <div class="container">
        <h1>PRODUCT OVERVIEW GUIDE GENERATOR</h1>
        <textarea id="urlInput" placeholder="Paste URLs here, one per line">

TITLE - ARTICULATING WALL MOUNT GUIDE
https://www.futureautomation.co.uk/Product/Details/PS32
https://www.futureautomation.co.uk/Product/Details/PS40
https://www.futureautomation.co.uk/Product/Details/PS55
https://www.futureautomation.co.uk/Product/Details/PS65
https://www.futureautomation.co.uk/Product/Details/PS80
SPLIT - https://www.futureautomation.co.uk/Product/Details/DA
https://www.futureautomation.co.uk/Product/Details/FSA1
https://www.futureautomation.co.uk/Product/Details/FSA2

TITLE - OUTDOOR / MARINE ARTICULATING WALL MOUNT GUIDE
https://www.futureautomation.co.uk/Product/Details/IP-PS40
https://www.futureautomation.co.uk/Product/Details/IP-PS55
https://www.futureautomation.co.uk/Product/Details/IP-PS65
https://www.futureautomation.co.uk/Product/Details/IP-PS80
SPLIT - https://www.futureautomation.co.uk/Product/Details/PS-M
https://www.futureautomation.co.uk/Product/Details/M-FSA2
https://www.futureautomation.co.uk/Product/Details/MSH
SPLIT - https://www.futureautomation.co.uk/Product/Details/IP-DA

TITLE - FIXED POSITION WALL MOUNT GUIDE
https://www.futureautomation.co.uk/Product/Details/FB22
https://www.futureautomation.co.uk/Product/Details/FB49
https://www.futureautomation.co.uk/Product/Details/FB80
https://www.futureautomation.co.uk/Product/Details/V74-MO
https://www.futureautomation.co.uk/Product/Details/M-V74
https://www.futureautomation.co.uk/Product/Details/MAG-V2

TITLE - WALL BOX GUIDE
GROUP - UNIVERSAL WALL BOXES
https://www.futureautomation.co.uk/Product/Details/WB
SPLIT 1 - https://www.futureautomation.co.uk/Product/Details/WB-2S            
https://www.futureautomation.co.uk/Product/Details/UB
GROUP - PRODUCT SPECIFIC WALL BOXES
https://www.futureautomation.co.uk/Product/Details/WB80
https://www.futureautomation.co.uk/Product/Details/WB-PSE90
https://www.futureautomation.co.uk/Product/Details/WB-QA2
https://www.futureautomation.co.uk/Product/Details/WB-DA
https://www.futureautomation.co.uk/Product/Details/WB-EAD
https://www.futureautomation.co.uk/Product/Details/WB-EAD-S
https://www.futureautomation.co.uk/Product/Details/WB-EAL
https://www.futureautomation.co.uk/Product/Details/WB-FSA1
https://www.futureautomation.co.uk/Product/Details/WB-FSA2
GROUP - WALL BOX BLANKING PLATES
https://www.futureautomation.co.uk/Product/Details/WB-BCP
https://www.futureautomation.co.uk/Product/Details/WB-VCP

TITLE - MOTORISED ARTICULATING WALL MOUNT GUIDE
GROUP - INDOOR
https://www.futureautomation.co.uk/Product/Details/FSE90
https://www.futureautomation.co.uk/Product/Details/PSE90
https://www.futureautomation.co.uk/Product/Details/HSE90
https://www.futureautomation.co.uk/Product/Details/QA2
https://www.futureautomation.co.uk/Product/Details/QA2-60
https://www.futureautomation.co.uk/Product/Details/HQA2
https://www.futureautomation.co.uk/Product/Details/IW-PTL
GROUP - MARINE INDOOR
https://www.futureautomation.co.uk/Product/Details/QA2-M
https://www.futureautomation.co.uk/Product/Details/QA2-60-M
https://www.futureautomation.co.uk/Product/Details/M-PSE90
GROUP - OUTDOOR / MARINE OUTDOOR
https://www.futureautomation.co.uk/Product/Details/QA2-MO
https://www.futureautomation.co.uk/Product/Details/QA2-60-MO

TITLE - SLIDING PANEL SYSTEM GUIDE
https://www.futureautomation.co.uk/Product/Details/SPS-V
https://www.futureautomation.co.uk/Product/Details/SPS-VS
https://www.futureautomation.co.uk/Product/Details/SPS-HZ
https://www.futureautomation.co.uk/Product/Details/SPS-HZS
https://www.futureautomation.co.uk/Product/Details/SPS-V-QA
https://www.futureautomation.co.uk/Product/Details/SPS-VS-QA
https://www.futureautomation.co.uk/Product/Details/SPS-HZ-QA
https://www.futureautomation.co.uk/Product/Details/SPS-HZS-QA

TITLE - CEILING MOUNT GUIDE
https://www.futureautomation.co.uk/Product/Details/CM
https://www.futureautomation.co.uk/Product/Details/CM-BLK
https://www.futureautomation.co.uk/Product/Details/CME
https://www.futureautomation.co.uk/Product/Details/CM-MO

TITLE - FIREPLACE DISPLAY MOUNT GUIDE
https://www.futureautomation.co.uk/Product/Details/EAD
https://www.futureautomation.co.uk/Product/Details/EAD-S
https://www.futureautomation.co.uk/Product/Details/EAD100
https://www.futureautomation.co.uk/Product/Details/EAL
https://www.futureautomation.co.uk/Product/Details/WB-EAD
https://www.futureautomation.co.uk/Product/Details/WB-EAD-S
https://www.futureautomation.co.uk/Product/Details/WB-EAL

TITLE - MOTORISED DISPLAY LIFTING GUIDE
https://www.futureautomation.co.uk/Product/Details/LSL
https://www.futureautomation.co.uk/Product/Details/LSL-EFA
https://www.futureautomation.co.uk/Product/Details/LSM
https://www.futureautomation.co.uk/Product/Details/LSM-EFA
https://www.futureautomation.co.uk/Product/Details/LSH
https://www.futureautomation.co.uk/Product/Details/LSM-TU
https://www.futureautomation.co.uk/Product/Details/AL675
https://www.futureautomation.co.uk/Product/Details/AL965
https://www.futureautomation.co.uk/Product/Details/TSL
https://www.futureautomation.co.uk/Product/Details/TSLH
https://www.futureautomation.co.uk/Product/Details/TSL-MO
https://www.futureautomation.co.uk/Product/Details/LSH-MO
https://www.futureautomation.co.uk/Product/Details/PL
https://www.futureautomation.co.uk/Product/Details/ML
https://www.futureautomation.co.uk/Product/Details/SRV-SBL

TITLE - CEILING HINGE RANGE GUIDE
GROUP - INDOOR RESIDENTIAL
https://www.futureautomation.co.uk/Product/Details/CHR
https://www.futureautomation.co.uk/Product/Details/CHRS
https://www.futureautomation.co.uk/Product/Details/CHRT
https://www.futureautomation.co.uk/Product/Details/CHRST
GROUP - INDOOR MARINE
https://www.futureautomation.co.uk/Product/Details/CHR-M
https://www.futureautomation.co.uk/Product/Details/CHRS-M
https://www.futureautomation.co.uk/Product/Details/CHR-C-M
https://www.futureautomation.co.uk/Product/Details/CHR-M-DDP
https://www.futureautomation.co.uk/Product/Details/CHRS-M-DDP
GROUP - OUTDOOR MARINE
https://www.futureautomation.co.uk/Product/Details/CHR-MO
https://www.futureautomation.co.uk/Product/Details/CHR-MO-DDP
https://www.futureautomation.co.uk/Product/Details/CHRS-MO
https://www.futureautomation.co.uk/Product/Details/CHRS-MO-DDP
        
        </textarea>
        <button id="generateButton" class='styled-button'>GENERATE PAGE ></button>
        <button type="button" onclick="printPage()" class='styled-button'>EXPORT AS PDF</button>
        <div class="checkbox-container">
            <input type="checkbox" id="splitProductCodes" name="splitProductCodes">
            <label for="splitProductCodes">Split All Product Codes</label>
        </div>
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        <div id="pagesContainer"></div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script>
const corsProxyAPI = 'https://api.codetabs.com/v1/proxy?quest=';
const delayBetweenRequests = 200;
const allSpecifications = {};
let previousUrls = [];
let toggleStates = {};
let lastUrlInput = '';

function extractCommonBaseName(productNames) {
    if (productNames.length === 1) {
        return removeTrailingNumbers(productNames[0]);
    }
    
    const baseNames = productNames.map(name => removeTrailingNumbers(name));
    const uniqueBaseNames = [...new Set(baseNames)];
    
    if (uniqueBaseNames.length === 1) {
        return uniqueBaseNames[0];
    }
    
    const commonPrefix = findLongestCommonPrefix(productNames);
    const commonSuffix = findLongestCommonSuffix(baseNames);
    
    if (commonPrefix && commonSuffix && commonPrefix !== commonSuffix) {
        return commonPrefix + commonSuffix;
    } else if (commonPrefix) {
        return commonPrefix.replace(/[-\d]*$/, '');
    }
    
    return productNames[0];
}

function removeTrailingNumbers(name) {
    return name.replace(/\d+/g, '');
}

function findLongestCommonPrefix(strings) {
    if (strings.length === 0) return '';
    if (strings.length === 1) return strings[0];
    
    let prefix = strings[0];
    for (let i = 1; i < strings.length; i++) {
        while (strings[i].indexOf(prefix) !== 0) {
            prefix = prefix.substring(0, prefix.length - 1);
            if (prefix === '') return '';
        }
    }
    return prefix;
}

function findLongestCommonSuffix(strings) {
    if (strings.length === 0) return '';
    if (strings.length === 1) return '';
    
    const reversedStrings = strings.map(s => s.split('').reverse().join(''));
    const reversedPrefix = findLongestCommonPrefix(reversedStrings);
    return reversedPrefix.split('').reverse().join('');
}

function printPage() {
    window.print();
}

async function fetchHTML(url) {
    try {
        const response = await fetch(`${corsProxyAPI}${encodeURIComponent(url)}`);
        const contentType = response.headers.get('Content-Type');
        if (contentType.includes('application/json')) {
            return (await response.json()).contents;
        }
        if (contentType.includes('text/html') || contentType.includes('text/plain')) {
            return await response.text();
        }
        return '';
    } catch (error) {
        console.error(`Error fetching URL ${url}:`, error);
        return '';
    }
}

function cleanTechnicalSpecificationTable(table) {
    Array.from(table.querySelectorAll('tr')).forEach(row => {
        if (row.querySelectorAll('button').length > 0) row.remove();
        Array.from(row.cells).forEach(cell => {
            const images = cell.querySelectorAll('img');
            if (images.length > 0) {
                images.forEach(image => image.remove());
                cell.querySelectorAll('strong').forEach(tag => tag.remove());
                if (cell.textContent.trim() === '' && !cell.querySelector('a')) cell.remove();
            }
        });
        if (row.cells.length === 0 || Array.from(row.cells).every(cell => cell.textContent.trim() === '' && !cell.querySelector('a'))) row.remove();
    });
}

async function scrapeProductData(url) {
    const html = await fetchHTML(url);
    if (!html) return { productName: 'Unknown Product', productImage: '', specifications: {}, subcodes: [], url };
    
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    const productName = doc.querySelector('#PageProductID')?.textContent.trim() || 'Unknown Product';
    const productImage = doc.querySelector('img[src^="https://d2oo5quzpsdib.cloudfront.net/Website/Product/Main/"]')?.src || '';
    const specifications = {};
    const subcodes = [];
    
    const heading = Array.from(doc.querySelectorAll('h2')).find(h2 => h2.textContent.includes('TECHNICAL SPECIFICATION'));
    if (heading && heading.nextElementSibling) {
        const table = heading.nextElementSibling.querySelector('table');
        if (table) {
            cleanTechnicalSpecificationTable(table);
            let headerCodes = [];
            const headerRow = table.querySelector('tr');
            if (headerRow) {
                headerCodes = Array.from(headerRow.querySelectorAll('th, td')).slice(1).map(cell => cell.textContent.trim());
            }
            
            Array.from(table.querySelectorAll('tr')).forEach((row, rowIndex) => {
                const cells = row.querySelectorAll('td, th');
                if (cells.length > 1) {
                    const key = cells[0].textContent.trim();
                    const values = Array.from(cells).slice(1).map(cell => cell.innerHTML.trim());
                    const codes = headerCodes.length > 0 ? headerCodes : values.map((_, i) => `${productName}${i + 1}`);
                    
                    specifications[key] = values.map((value, index) => ({
                        value: value,
                        subcode: codes[index] || productName
                    }));
                    
                    if (key.toUpperCase() === 'PRODUCT CODE') {
                        codes.forEach(code => {
                            if (code && !subcodes.includes(code)) subcodes.push(code);
                        });
                    }
                }
            });
        }
    }
    return { productName, productImage, specifications, subcodes, url };
}

function simplifySizes(values, spec, splitProductCodes) {
    const specUpper = spec.toUpperCase();
    return values.map(item => {
        if (['TECH SHEET', 'SELL SHEET', 'CAD'].includes(specUpper)) return item;
        if ((specUpper.includes('MAX') || specUpper.includes('MAXIMUM')) && !splitProductCodes) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = item.value;
            const textContent = tempDiv.textContent.trim();
            
            if (textContent.toUpperCase().includes('LEFT') && textContent.toUpperCase().includes('RIGHT')) {
                return item;
            }
            
            return { value: textContent.split(', ').pop().trim(), subcode: item.subcode };
        }
        return item;
    });
}

function selectCompactValue(values, spec, productName) {
    const specUpper = spec.toUpperCase();
    if (specUpper.includes('MAX') || specUpper.includes('MAX.') || specUpper.includes('MAXIMUM') || 
        specUpper.includes('SHIPPING') || specUpper.includes('SHIP') || specUpper.includes('WEIGHT')) {
        
        if (values.length > 0) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = values[values.length - 1].value;
            const textContent = tempDiv.textContent.trim();
            
            if (textContent.toUpperCase().includes('LEFT') && textContent.toUpperCase().includes('RIGHT')) {
                return values;
            }
        }
        
        const lastValue = values[values.length - 1]?.value || 'N/A';
        return [{ value: lastValue, subcode: productName }];
    }
    return values;
}

function adjustTitleFontSize(titleElement, text) {
    const minFontSize = 12;
    const maxFontSize = 20;
    const baseLength = 20;
    const scaleFactor = Math.min(1, baseLength / text.length);
    const fontSize = minFontSize + (maxFontSize - minFontSize) * scaleFactor;
    titleElement.style.fontSize = `${fontSize}pt`;
}

function updateRowColors(table) {
    const visibleRows = Array.from(table.querySelectorAll('tbody tr')).filter(tr => tr.style.display !== 'none');
    visibleRows.forEach((row, index) => {
        row.classList.remove('grey-row', 'white-row');
        if (index % 2 === 0) {
            row.classList.add('white-row');
        } else {
            row.classList.add('grey-row');
        }
    });
}

function createSectionTable(sectionData, sectionIndex, pageIndex) {
    const table = document.createElement('table');
    table.classList.add('section-table');
    table.id = `section${sectionIndex}_table${pageIndex}`;
    
    const thead = document.createElement('thead');
    const tbody = document.createElement('tbody');
    table.appendChild(thead);
    table.appendChild(tbody);
    
    const productCount = sectionData.products.length;
    const specColumnWidth = '10%';
    const productColumnWidth = productCount > 0 ? `${75 / productCount}%` : '75%';
    
    const headerRow = document.createElement('tr');
    const specHeader = document.createElement('th');
    specHeader.textContent = 'SPECIFICATION';
    specHeader.style.width = specColumnWidth;
    headerRow.appendChild(specHeader);
    
    let hasGroupRows = false;
    const groupRow = document.createElement('tr');
    groupRow.classList.add('group-row');
    const emptyGroupTh = document.createElement('th');
    emptyGroupTh.style.width = specColumnWidth;
    groupRow.appendChild(emptyGroupTh);
    
    if (sectionData.groups && sectionData.groups.length > 0) {
        hasGroupRows = true;
        sectionData.groups.forEach(group => {
            const th = document.createElement('th');
            th.textContent = group.name;
            th.colSpan = group.productCount;
            const groupWidth = `${(75 * group.productCount) / productCount}%`;
            th.style.width = groupWidth;
            groupRow.appendChild(th);
        });
    }
    
    sectionData.products.forEach(product => {
        const th = document.createElement('th');
        th.style.width = productColumnWidth;
        const a = document.createElement('a');
        const productCode = product.shouldSplit ? (product.subcodes[0] || product.productName) : product.productName;
        a.href = product.url;
        a.textContent = productCode;
        th.appendChild(a);
        headerRow.appendChild(th);
    });
    
    if (hasGroupRows) {
        thead.appendChild(groupRow);
    }
    thead.appendChild(headerRow);
    
    const imageRow = document.createElement('tr');
    const imageCell = document.createElement('td');
    imageCell.textContent = 'PRODUCT IMAGE';
    imageCell.style.width = specColumnWidth;
    imageRow.appendChild(imageCell);
    
    sectionData.products.forEach(product => {
        const imgCell = document.createElement('td');
        imgCell.style.width = productColumnWidth;
        const img = document.createElement('img');
        img.src = product.productImage;
        img.style.maxWidth = '100%';
        img.style.height = 'auto';
        imgCell.appendChild(img);
        imageRow.appendChild(imgCell);
    });
    
    tbody.appendChild(imageRow);
    
    const regularSpecs = sectionData.specs.filter(spec => {
        const specUpper = spec.toUpperCase();
        return specUpper !== 'TECH SHEET' && specUpper !== 'TECHNICAL SHEET';
    });
    const techSpecs = sectionData.specs.filter(spec => {
        const specUpper = spec.toUpperCase();
        return specUpper === 'TECH SHEET' || specUpper === 'TECHNICAL SHEET';
    });
    
    [...regularSpecs, ...techSpecs].forEach(spec => {
        if (!sectionData.specVisibility[spec]) return;
        
        const tr = document.createElement('tr');
        const tdSpec = document.createElement('td');
        tdSpec.textContent = spec;
        tdSpec.style.width = specColumnWidth;
        tr.appendChild(tdSpec);
        
        sectionData.products.forEach(product => {
            const tdValue = document.createElement('td');
            tdValue.style.width = productColumnWidth;
            let values = product.specifications[spec] || [];
            
            if (!product.shouldSplit) {
                values = selectCompactValue(values, spec, product.productName);
            }
            values = simplifySizes(values, spec, product.shouldSplit);
            
            if (values.length === 0) {
                tdValue.innerHTML = 'N/A';
            } else {
                const specUpper = spec.toUpperCase();
                if (product.shouldSplit) {
                    tdValue.innerHTML = `<div class="cell-value">${values[0]?.value || 'N/A'}</div>`;
                } else {
                    const valueGroups = {};
                    values.forEach(item => {
                        const valueKey = item.value;
                        if (!valueGroups[valueKey]) {
                            valueGroups[valueKey] = [];
                        }
                        valueGroups[valueKey].push(item.subcode);
                    });

                    const uniqueValues = Object.keys(valueGroups);
                    const isSingleValue = uniqueValues.length === 1;

                    if (specUpper === 'TECHNICAL SHEET' || specUpper === 'TECH SHEET') {
                        tdValue.innerHTML = values.map(item => item.value).join(' ');
                    } else if (specUpper === 'PRODUCT CODE') {
                        tdValue.innerHTML = `<div class="cell-value">${values.map(item => item.subcode).join(', ')}</div>`;
                    } else if (isSingleValue) {
                        tdValue.innerHTML = `<div class="cell-value">${uniqueValues[0]}</div>`;
                    } else {
                        const formattedValues = Object.entries(valueGroups).map(([value, subcodes]) => {
                            return `<div class="cell-value"><strong>${subcodes.join(', ')}</strong></div><div class="cell-value">${value}</div>`;
                        });
                        tdValue.innerHTML = formattedValues.join('');
                    }
                }
            }
            
            tr.appendChild(tdValue);
        });
        
        tbody.appendChild(tr);
    });
    
    updateRowColors(table);
    return table;
}

function rebuildSectionTable(sectionIndex, pageIndex) {
    const sectionData = window.pageSections[pageIndex][sectionIndex];
    const tableWrapper = document.getElementById(`tableWrapper${pageIndex}`);
    const oldTable = document.getElementById(`section${sectionIndex}_table${pageIndex}`);
    const newTable = createSectionTable(sectionData, sectionIndex, pageIndex);
    
    if (oldTable) {
        tableWrapper.replaceChild(newTable, oldTable);
    }
    
    setTimeout(() => {
        setConsistentImageHeights(pageIndex);
        adjustFontSizeBasedOnTableContent(pageIndex);
    }, 10);
}

function setConsistentImageHeights(pageIndex) {
    const tableWrapper = document.getElementById(`tableWrapper${pageIndex}`);
    if (!tableWrapper) return;
    
    const tables = tableWrapper.querySelectorAll('.section-table');
    if (tables.length === 0) return;
    
    tables.forEach(table => {
        const imageRow = table.querySelector('tbody tr:first-child');
        if (imageRow) {
            imageRow.style.height = '';
            imageRow.querySelectorAll('td').forEach(cell => {
                cell.style.height = '';
                cell.style.width = '';
                cell.style.minWidth = '';
                cell.style.maxWidth = '';
                const img = cell.querySelector('img');
                if (img) {
                    img.style.maxWidth = '';
                    img.style.maxHeight = '';
                    img.style.width = '';
                    img.style.height = '';
                    img.style.objectFit = '';
                }
            });
        }
    });
    
    tableWrapper.offsetHeight;
    
    const maxImageHeight = 180;
    const minImageHeight = 150;
    
    const wrapperHeight = tableWrapper.clientHeight;
    
    let totalNonImageHeight = 0;
    tables.forEach(table => {
        const allRows = Array.from(table.querySelectorAll('tr')).filter(tr => tr.style.display !== 'none');
        const imageRow = table.querySelector('tbody tr:first-child');
        allRows.forEach(row => {
            if (row !== imageRow) {
                totalNonImageHeight += row.offsetHeight || 25;
            }
        });
    });
    
    const availableHeightForImages = wrapperHeight - totalNonImageHeight;
    const imageRowCount = tables.length;
    const maxAllowedImageHeight = Math.max(minImageHeight, Math.floor(availableHeightForImages / imageRowCount));
    
    if (tables.length === 1) {
        const firstImageCell = tables[0].querySelector('tbody tr:first-child td:nth-child(2)');
        if (firstImageCell) {
            const cellWidth = firstImageCell.offsetWidth;
            const imageRow = tables[0].querySelector('tbody tr:first-child');
            if (imageRow) {
                const constrainedHeight = Math.min(cellWidth, maxImageHeight, maxAllowedImageHeight);
                imageRow.style.height = `${constrainedHeight}px`;
                imageRow.querySelectorAll('td').forEach(cell => {
                    cell.style.height = `${constrainedHeight}px`;
                    cell.style.verticalAlign = 'middle';
                    const img = cell.querySelector('img');
                    if (img) {
                        img.style.maxWidth = '100%';
                        img.style.maxHeight = `${constrainedHeight}px`;
                        img.style.height = 'auto';
                        img.style.objectFit = 'contain';
                    }
                });
            }
        }
        return;
    }
    
    let minCellWidth = Infinity;
    
    tables.forEach(table => {
        const firstImageCell = table.querySelector('tbody tr:first-child td:nth-child(2)');
        if (firstImageCell) {
            const cellWidth = firstImageCell.offsetWidth;
            minCellWidth = Math.min(minCellWidth, cellWidth);
        }
    });
    
    let needsConstraint = false;
    tables.forEach(table => {
        const firstImageCell = table.querySelector('tbody tr:first-child td:nth-child(2)');
        if (firstImageCell && Math.abs(firstImageCell.offsetWidth - minCellWidth) > 1) {
            needsConstraint = true;
        }
    });
    
    if (needsConstraint && minCellWidth > 0 && minCellWidth !== Infinity) {
        const constrainedHeight = Math.min(minCellWidth, maxImageHeight, maxAllowedImageHeight);
        tables.forEach(table => {
            const imageRow = table.querySelector('tbody tr:first-child');
            if (imageRow) {
                imageRow.style.height = `${constrainedHeight}px`;
                imageRow.querySelectorAll('td').forEach(cell => {
                    cell.style.height = `${constrainedHeight}px`;
                    cell.style.width = `${constrainedHeight}px`;
                    cell.style.verticalAlign = 'middle';
                    const img = cell.querySelector('img');
                    if (img) {
                        img.style.maxWidth = '100%';
                        img.style.maxHeight = `${constrainedHeight}px`;
                        img.style.width = 'auto';
                        img.style.height = 'auto';
                        img.style.objectFit = 'contain';
                    }
                });
            }
        });
    } else {
        tables.forEach(table => {
            const imageRow = table.querySelector('tbody tr:first-child');
            if (imageRow) {
                const firstImageCell = imageRow.querySelector('td:nth-child(2)');
                if (firstImageCell) {
                    const cellWidth = firstImageCell.offsetWidth;
                    const constrainedHeight = Math.min(cellWidth, maxImageHeight, maxAllowedImageHeight);
                    imageRow.style.height = `${constrainedHeight}px`;
                    imageRow.querySelectorAll('td').forEach(cell => {
                        cell.style.height = `${constrainedHeight}px`;
                        cell.style.verticalAlign = 'middle';
                        const img = cell.querySelector('img');
                        if (img) {
                            img.style.maxWidth = '100%';
                            img.style.maxHeight = `${constrainedHeight}px`;
                            img.style.height = 'auto';
                            img.style.objectFit = 'contain';
                        }
                    });
                }
            }
        });
    }
}

async function updateTables() {
    const urlInput = document.getElementById('urlInput').value;
    const splitProductCodes = document.getElementById('splitProductCodes').checked;
    const lines = urlInput.split('\n').map(line => line.trim()).filter(line => line !== '');
    
    const pages = [];
    let currentPage = null;
    
    lines.forEach(line => {
        if (line.startsWith('TITLE -')) {
            if (currentPage) {
                pages.push(currentPage);
            }
            currentPage = {
                title: line.replace('TITLE -', '').trim(),
                sections: [{ groups: [], urls: [] }]
            };
        } else if (line === 'DIVIDER') {
            if (!currentPage) {
                currentPage = { title: '', sections: [{ groups: [], urls: [] }] };
            }
            currentPage.sections.push({ groups: [], urls: [] });
        } else if (line.startsWith('GROUP - ')) {
            if (!currentPage) {
                currentPage = { title: '', sections: [{ groups: [], urls: [] }] };
            }
            const currentSection = currentPage.sections[currentPage.sections.length - 1];
            currentSection.groups.push({
                name: line.replace('GROUP - ', '').trim(),
                urls: []
            });
        } else if (line.startsWith('http') || line.startsWith('SPLIT') || line.startsWith('MERGE')) {
            if (!currentPage) {
                currentPage = { title: '', sections: [{ groups: [], urls: [] }] };
            }
            
            let url, shouldSplit, splitIndex = null, mergeId = null;
            
            if (line.startsWith('MERGE ')) {
                const mergeMatch = line.match(/^MERGE (\w+) - (.+)$/);
                if (mergeMatch) {
                    mergeId = mergeMatch[1];
                    url = mergeMatch[2].trim();
                    shouldSplit = false;
                } else {
                    url = line.replace('MERGE', '').replace(/^[\s-]+/, '').trim();
                    shouldSplit = false;
                    mergeId = 'default';
                }
            } else if (line.startsWith('SPLIT ')) {
                const match = line.match(/^SPLIT (\d+) - (.+)$/);
                if (match) {
                    splitIndex = parseInt(match[1]) - 1;
                    url = match[2].trim();
                    shouldSplit = true;
                } else if (line.startsWith('SPLIT - ')) {
                    url = line.replace('SPLIT - ', '').trim();
                    shouldSplit = true;
                } else {
                    url = line.replace('SPLIT', '').replace(/^[\s-]+/, '').trim();
                    shouldSplit = splitProductCodes;
                }
            } else {
                url = line;
                shouldSplit = splitProductCodes;
            }
            
            const currentSection = currentPage.sections[currentPage.sections.length - 1];
            const currentGroup = currentSection.groups.length > 0 ? currentSection.groups[currentSection.groups.length - 1] : null;
            const urlObject = { url, shouldSplit, splitIndex, mergeId };
            
            if (currentGroup) {
                currentGroup.urls.push(urlObject);
            } else {
                currentSection.urls.push(urlObject);
            }
        }
    });
    
    if (currentPage) {
        pages.push(currentPage);
    }
    
    if (pages.length === 0) {
        pages.push({ title: '', sections: [{ groups: [], urls: [] }] });
    }

    const progressContainer = document.getElementById('progressContainer');
    const progressBar = document.getElementById('progressBar');
    progressContainer.style.display = 'block';
    progressBar.style.width = '0%';
    
    const pagesContainer = document.getElementById('pagesContainer');
    pagesContainer.innerHTML = '';
    
    const totalUrls = pages.reduce((sum, page) => 
        sum + page.sections.reduce((sectionSum, section) => 
            sectionSum + (section.groups.flatMap(g => g.urls).length + section.urls.length), 0), 0);
    let processedUrls = 0;
    
    window.pageSections = [];
    
    for (let pageIndex = 0; pageIndex < pages.length; pageIndex++) {
        const page = pages[pageIndex];
        const productDataMap = new Map();
        
        for (const section of page.sections) {
            const effectiveUrls = section.groups.length > 0 ? section.groups.flatMap(g => g.urls) : section.urls;
            
            for (const { url, shouldSplit, splitIndex, mergeId } of effectiveUrls) {
                if (!productDataMap.has(url)) {
                    let productData = await scrapeProductData(url);
                    productDataMap.set(url, productData);
                    processedUrls++;
                    const progressPercentage = (processedUrls / totalUrls) * 100;
                    progressBar.style.width = `${progressPercentage}%`;
                    await new Promise(resolve => setTimeout(resolve, delayBetweenRequests));
                }
            }
        }
        
        const pageWrapper = document.createElement('div');
        pageWrapper.classList.add('page-wrapper');
        
        const dropdownToggle = document.createElement('button');
        dropdownToggle.classList.add('dropdown-toggle');
        dropdownToggle.textContent = 'CATEGORIES';
        dropdownToggle.dataset.pageIndex = pageIndex;
        
        const dropdownContent = document.createElement('div');
        dropdownContent.classList.add('dropdown-content');
        dropdownContent.id = `buttonContainer${pageIndex}`;
        
        dropdownToggle.onclick = () => {
            dropdownContent.classList.toggle('show');
            dropdownToggle.classList.toggle('active');
        };
        
        pageWrapper.appendChild(dropdownToggle);
        pageWrapper.appendChild(dropdownContent);
        
        const a4Container = document.createElement('div');
        a4Container.classList.add('a4-container');
        a4Container.innerHTML = `
            <img src="https://s3.eu-west-1.amazonaws.com/cdn.futureautomation.co.uk/Files/Logo+Centered+-+Black.svg" alt="Logo" class="logo">
            <div class="title" id="pageTitle${pageIndex}">${page.title || ''}</div>
            <div class="contact-info">
                <b>UK</b> 01438 833 577<br>
                <b>USA</b> 603.742.9181<br>
                info@futureautomation.net
            </div>
            <div class="table-wrapper" id="tableWrapper${pageIndex}">
            </div>
            <div class="footer">
                www.<b>FUTUREAUTOMATION</b>.net<br>
                Future Sound and Vision Ltd. Registered in England. Company Number: 05124376.<br>
                Registered Office: Unit 2 Kimpton Enterprise Park, Claggy Road, Kimpton, Herts, SG4 8HP
            </div>
        `;
        pageWrapper.appendChild(a4Container);
        pagesContainer.appendChild(pageWrapper);
        
        const titleElement = document.getElementById(`pageTitle${pageIndex}`);
        if (page.title) adjustTitleFontSize(titleElement, page.title);
        else titleElement.style.fontSize = '12pt';
        
        const tableWrapper = document.getElementById(`tableWrapper${pageIndex}`);
        const sections = [];
        const defaultHiddenSpecs = ['DOWNLOADS', 'EXAMPLE TECHNICAL SHEETS', 'SHIPPING DIMENSIONS', 'VIDEO INSTRUCTIONS', 'SHIPPING WEIGHT', 'WHAT\'S INCLUDED'];
        
        page.sections.forEach((section, sectionIndex) => {
            const sectionProducts = [];
            const effectiveUrls = section.groups.length > 0 ? section.groups.flatMap(g => g.urls) : section.urls;
            
            const mergeGroups = {};
            const nonMergeUrls = [];
            
            effectiveUrls.forEach((urlObj) => {
                if (urlObj.mergeId) {
                    if (!mergeGroups[urlObj.mergeId]) {
                        mergeGroups[urlObj.mergeId] = [];
                    }
                    mergeGroups[urlObj.mergeId].push(urlObj);
                } else {
                    nonMergeUrls.push(urlObj);
                }
            });
            
            Object.values(mergeGroups).forEach(mergeGroup => {
                if (mergeGroup.length === 1) {
                    nonMergeUrls.push(mergeGroup[0]);
                    return;
                }
                
                const products = mergeGroup.map(({ url }) => productDataMap.get(url)).filter(Boolean);
                if (products.length === 0) return;
                
                const baseProduct = products[0];
                const allProductNames = products.map(p => p.productName);
                const baseName = extractCommonBaseName(allProductNames);
                
                const mergedProduct = {
                    ...baseProduct,
                    productName: baseName,
                    shouldSplit: false,
                    specifications: {},
                    subcodes: [baseName]
                };
                
                const allSpecs = new Set();
                products.forEach(product => {
                    Object.keys(product.specifications).forEach(spec => allSpecs.add(spec));
                });
                
                allSpecs.forEach(spec => {
                    const allValues = [];
                    const seenValues = new Set();
                    
                    products.forEach(product => {
                        if (product.specifications[spec] && product.specifications[spec].length > 0) {
                            product.specifications[spec].forEach(specValue => {
                                const valueKey = `${specValue.value}|${specValue.subcode}`;
                                if (!seenValues.has(valueKey)) {
                                    seenValues.add(valueKey);
                                    allValues.push({
                                        value: specValue.value,
                                        subcode: specValue.subcode
                                    });
                                }
                            });
                        }
                    });
                    
                    if (allValues.length > 0) {
                        mergedProduct.specifications[spec] = allValues;
                    }
                });
                
                sectionProducts.push(mergedProduct);
            });
            
            nonMergeUrls.forEach(({ url, shouldSplit, splitIndex }) => {
                const product = productDataMap.get(url);
                if (!product) return;
                
                if (splitIndex !== null) {
                    if (product.subcodes.length > splitIndex) {
                        const subcode = product.subcodes[splitIndex];
                        const newProduct = { ...product, subcodes: [subcode], productName: subcode };
                        const newSpecifications = {};
                        Object.keys(product.specifications).forEach(spec => {
                            const values = product.specifications[spec] || [];
                            const matchingValue = values[splitIndex];
                            newSpecifications[spec] = matchingValue ? [matchingValue] : [];
                        });
                        newProduct.specifications = newSpecifications;
                        newProduct.shouldSplit = true;
                        sectionProducts.push(newProduct);
                    }
                } else if (shouldSplit && product.subcodes.length > 1) {
                    product.subcodes.forEach((subcode, index) => {
                        const newProduct = { ...product, subcodes: [subcode], productName: subcode };
                        const newSpecifications = {};
                        Object.keys(product.specifications).forEach(spec => {
                            const values = product.specifications[spec] || [];
                            const matchingValue = values[index];
                            newSpecifications[spec] = matchingValue ? [matchingValue] : [];
                        });
                        newProduct.specifications = newSpecifications;
                        newProduct.shouldSplit = true;
                        sectionProducts.push(newProduct);
                    });
                } else {
                    const productCopy = { ...product, shouldSplit };
                    sectionProducts.push(productCopy);
                }
            });
            
            const sectionSpecs = [...new Set(sectionProducts.flatMap(product => Object.keys(product.specifications)))];
            const specVisibility = {};
            sectionSpecs.forEach(spec => {
                const specUpper = spec.toUpperCase();
                if (!["CAD", "INSTRUCTIONS", "SELL SHEET"].includes(specUpper)) {
                    specVisibility[spec] = !defaultHiddenSpecs.includes(specUpper);
                }
            });
            
            const sectionGroups = [];
            if (section.groups.length > 0) {
                section.groups.forEach(group => {
                    let productCount = 0;
                    const mergeGroups = {};
                    const nonMergeUrls = [];
                    
                    group.urls.forEach((urlObj) => {
                        if (urlObj.mergeId) {
                            if (!mergeGroups[urlObj.mergeId]) {
                                mergeGroups[urlObj.mergeId] = [];
                            }
                            mergeGroups[urlObj.mergeId].push(urlObj);
                        } else {
                            nonMergeUrls.push(urlObj);
                        }
                    });
                    
                    Object.values(mergeGroups).forEach(mergeGroup => {
                        if (mergeGroup.length === 1) {
                            nonMergeUrls.push(mergeGroup[0]);
                            return;
                        }
                        productCount += 1;
                    });
                    
                    nonMergeUrls.forEach(({ url, shouldSplit, splitIndex }) => {
                        const product = productDataMap.get(url);
                        if (product) {
                            if (splitIndex !== null) {
                                productCount += 1;
                            } else if (shouldSplit) {
                                productCount += product.subcodes.length;
                            } else {
                                productCount += 1;
                            }
                        }
                    });
                    
                    sectionGroups.push({ name: group.name, productCount });
                });
            }
            
            const sectionData = {
                products: sectionProducts,
                specs: sectionSpecs,
                specVisibility: specVisibility,
                groups: sectionGroups
            };
            
            sections.push(sectionData);
            
            const sectionTable = createSectionTable(sectionData, sectionIndex, pageIndex);
            tableWrapper.appendChild(sectionTable);
            
            const sectionControlsDiv = document.createElement('div');
            sectionControlsDiv.classList.add('section-controls');
            const sectionTitle = document.createElement('div');
            sectionTitle.classList.add('section-title');
            sectionTitle.textContent = `Section ${sectionIndex + 1}`;
            sectionControlsDiv.appendChild(sectionTitle);
            
            sectionSpecs.forEach(spec => {
                const specUpper = spec.toUpperCase();
                if (["CAD", "INSTRUCTIONS", "SELL SHEET"].includes(specUpper)) return;
                
                const button = document.createElement('button');
                button.textContent = spec;
                button.classList.add('toggle-button');
                button.dataset.pageIndex = pageIndex;
                button.dataset.spec = spec;
                button.dataset.sectionIndex = sectionIndex;
                
                if (defaultHiddenSpecs.includes(specUpper)) {
                    button.classList.add('active');
                }
                
                button.onclick = () => {
                    sections[sectionIndex].specVisibility[spec] = !sections[sectionIndex].specVisibility[spec];
                    button.classList.toggle('active');
                    rebuildSectionTable(sectionIndex, pageIndex);
                };
                
                sectionControlsDiv.appendChild(button);
            });
            
            const buttonContainer = document.getElementById(`buttonContainer${pageIndex}`);
            buttonContainer.appendChild(sectionControlsDiv);
        });
        
        window.pageSections[pageIndex] = sections;
        
        setConsistentImageHeights(pageIndex);
        adjustFontSizeBasedOnTableContent(pageIndex);
    }
    
    progressContainer.style.display = 'none';
    document.getElementById('generateButton').disabled = true;
}

function adjustFontSizeBasedOnTableContent(pageIndex) {
    const tableWrapper = document.getElementById(`tableWrapper${pageIndex}`);
    if (!tableWrapper) return;
    
    const tables = tableWrapper.querySelectorAll('.section-table');
    if (tables.length === 0) return;
    
    const maxFontSize = 12;
    const minFontSize = 5;
    let globalOptimalFontSize = maxFontSize;
    
    tables.forEach(table => {
        const cells = table.querySelectorAll('th, td');
        cells.forEach(cell => cell.style.fontSize = '');
    });
    
    tableWrapper.offsetHeight;
    
    tables.forEach(table => {
        const visibleRows = Array.from(table.querySelectorAll('tr')).filter(tr => tr.style.display !== 'none');
        if (visibleRows.length === 0) return;
        
        let tableOptimalFontSize = maxFontSize;
        
        visibleRows.forEach(row => {
            const visibleCells = Array.from(row.querySelectorAll('th, td')).filter(cell => {
                const style = window.getComputedStyle(cell);
                return cell.style.display !== 'none' && style.visibility !== 'hidden';
            });
            
            visibleCells.forEach(cell => {
                if (cell.querySelector('img')) return;
                
                const computedStyle = window.getComputedStyle(cell);
                const paddingTop = parseFloat(computedStyle.paddingTop);
                const paddingBottom = parseFloat(computedStyle.paddingBottom);
                const paddingLeft = parseFloat(computedStyle.paddingLeft);
                const paddingRight = parseFloat(computedStyle.paddingRight);
                const cellHeight = cell.clientHeight - paddingTop - paddingBottom;
                const cellWidth = cell.clientWidth - paddingLeft - paddingRight;
                
                if (cellHeight <= 0 || cellWidth <= 0 || !cell.textContent.trim()) return;
                
                cell.style.fontSize = `${maxFontSize}px`;
                const textHeight = cell.scrollHeight;
                const textWidth = cell.scrollWidth;
                const heightRatio = cellHeight / textHeight;
                const widthRatio = cellWidth / textWidth;
                const scaleFactor = Math.min(heightRatio, widthRatio);
                let cellFontSize = Math.floor(maxFontSize * scaleFactor);
                cellFontSize = Math.max(minFontSize, Math.min(cellFontSize, maxFontSize));
                tableOptimalFontSize = Math.min(tableOptimalFontSize, cellFontSize);
            });
        });
        
        globalOptimalFontSize = Math.min(globalOptimalFontSize, tableOptimalFontSize);
    });
    
    const totalVisibleRows = Array.from(tables).reduce((count, table) => {
        return count + Array.from(table.querySelectorAll('tr')).filter(tr => tr.style.display !== 'none').length;
    }, 0);
    
    if (totalVisibleRows > 30) {
        const rowPenalty = Math.max(0.5, 1 - (totalVisibleRows - 30) * 0.02);
        globalOptimalFontSize = Math.floor(globalOptimalFontSize * rowPenalty);
    }
    
    globalOptimalFontSize = Math.max(minFontSize, globalOptimalFontSize);
    
    tables.forEach(table => {
        const cells = table.querySelectorAll('th, td');
        cells.forEach(cell => cell.style.fontSize = `${globalOptimalFontSize}px`);
        
        const groupRow = table.querySelector('.group-row');
        const specRow = table.querySelector('thead tr:not(.group-row)');
        if (groupRow && specRow) {
            groupRow.style.height = `${specRow.offsetHeight}px`;
        }
        
        updateRowColors(table);
    });
    
    setTimeout(() => {
        const wrapperHeight = tableWrapper.clientHeight;
        const totalTableHeight = Array.from(tables).reduce((sum, table) => {
            const visibleRows = Array.from(table.querySelectorAll('tr')).filter(tr => tr.style.display !== 'none');
            return sum + visibleRows.reduce((rowSum, row) => rowSum + row.offsetHeight, 0);
        }, 0);
        
        if (totalTableHeight > wrapperHeight * 0.98) {
            const heightRatio = (wrapperHeight * 0.95) / totalTableHeight;
            const newFontSize = Math.max(minFontSize, Math.floor(globalOptimalFontSize * heightRatio));
            
            if (newFontSize < globalOptimalFontSize) {
                tables.forEach(table => {
                    const cells = table.querySelectorAll('th, td');
                    cells.forEach(cell => cell.style.fontSize = `${newFontSize}px`);
                });
            }
        }
    }, 50);
}

function setupTableObservers() {
    const observer = new MutationObserver(() => {
        const tables = document.querySelectorAll('table[id^="section"]');
        tables.forEach(table => {
            const pageIndex = parseInt(table.id.match(/table(\d+)$/)[1]);
            adjustFontSizeBasedOnTableContent(pageIndex);
        });
    });
    
    document.addEventListener('DOMContentLoaded', () => {
        observer.observe(document.body, { childList: true, subtree: true });
    });
}

document.addEventListener('DOMContentLoaded', () => {
    setupTableObservers();
    document.getElementById('generateButton').addEventListener('click', () => {
        updateTables();
        lastUrlInput = document.getElementById('urlInput').value;
        document.getElementById('generateButton').disabled = true;
    });
    document.getElementById('urlInput').addEventListener('input', () => {
        const currentUrlInput = document.getElementById('urlInput').value;
        document.getElementById('generateButton').disabled = currentUrlInput === lastUrlInput;
    });
    document.getElementById('splitProductCodes').addEventListener('change', () => {
        document.getElementById('generateButton').disabled = false;
    });
});
</script>
</body>
</html>
